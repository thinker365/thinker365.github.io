(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{670:function(t,e,a){"use strict";a.r(e);var r=a(35),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#charles-工作原理"}},[t._v("Charles 工作原理")])]),a("li",[a("a",{attrs:{href:"#搭建基础代理环境-web端与app端"}},[t._v("搭建基础代理环境（Web端与App端）")]),a("ul",[a("li",[a("a",{attrs:{href:"#web-端"}},[t._v("Web 端")])]),a("li",[a("a",{attrs:{href:"#app-端"}},[t._v("App 端")])])])]),a("li",[a("a",{attrs:{href:"#接口过滤、拦截和修改-过滤接口请求与动态修改请求数据"}},[t._v("接口过滤、拦截和修改（过滤接口请求与动态修改请求数据）")]),a("ul",[a("li",[a("a",{attrs:{href:"#过滤接口请求"}},[t._v("过滤接口请求")])]),a("li",[a("a",{attrs:{href:"#动态修改请求数据"}},[t._v("动态修改请求数据")])])])]),a("li",[a("a",{attrs:{href:"#远程映射"}},[t._v("远程映射")])]),a("li",[a("a",{attrs:{href:"#慢网络模拟"}},[t._v("慢网络模拟")])]),a("li",[a("a",{attrs:{href:"#微服务分支测试"}},[t._v("微服务分支测试")])]),a("li",[a("a",{attrs:{href:"#简单接口并发测试"}},[t._v("简单接口并发测试")])]),a("li",[a("a",{attrs:{href:"#charles-应用常见问题"}},[t._v("Charles 应用常见问题")]),a("ul",[a("li",[a("a",{attrs:{href:"#【question-1-】"}},[t._v("【Question 1 】")])]),a("li",[a("a",{attrs:{href:"#【question-2-】"}},[t._v("【Question 2 】")])]),a("li",[a("a",{attrs:{href:"#【question-3-】"}},[t._v("【Question 3 】")])]),a("li",[a("a",{attrs:{href:"#【question-4-】"}},[t._v("【Question 4 】")])]),a("li",[a("a",{attrs:{href:"#【question-5-】"}},[t._v("【Question 5 】")])])])]),a("li",[a("a",{attrs:{href:"#参考"}},[t._v("参考")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"charles-工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#charles-工作原理"}},[t._v("#")]),t._v(" Charles 工作原理")]),t._v(" "),a("p",[t._v("Charles 的工作原理类似于中间人代理，即任何客户端和服务端的通信都会经过 Charles，于是 Charles 便可以拦截来自客户端和服务端的任何请求，并进行修改")]),t._v(" "),a("h2",{attrs:{id:"搭建基础代理环境-web端与app端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#搭建基础代理环境-web端与app端"}},[t._v("#")]),t._v(" 搭建基础代理环境（Web端与App端）")]),t._v(" "),a("h3",{attrs:{id:"web-端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-端"}},[t._v("#")]),t._v(" Web 端")]),t._v(" "),a("ol",[a("li",[t._v("下载安装："),a("a",{attrs:{href:"https://www.charlesproxy.com",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.charlesproxy.com"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("安装根证书，位置在 Help--\x3e SSL Proxying --\x3e Install Charles Root Certificate")]),t._v(" "),a("li",[t._v("证书安装后，点击 Charles 的菜单， 选择 Proxy--\x3emacOS Proxy.")]),t._v(" "),a("li",[t._v("如果想抓包 HTTPS 的请求，则需要通过 Charles 的菜单 Proxy--\x3eSSL Proxying Settings 来进行设置\n"),a("ul",[a("li",[t._v("在弹出的对话框中，勾选Enable SSL Proxying")]),t._v(" "),a("li",[t._v("点击 ADD 按钮，编辑，Host 填*，Port 填写 443")])])])]),t._v(" "),a("h3",{attrs:{id:"app-端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#app-端"}},[t._v("#")]),t._v(" App 端")]),t._v(" "),a("ol",[a("li",[t._v("在菜单 Proxy--\x3eProxy Settings 进行以下设置\n"),a("ul",[a("li",[t._v("代理端口 8888（也可以自定义填其他端口）")]),t._v(" "),a("li",[t._v("勾上Enable transparent HTTP proxying")]),t._v(" "),a("li",[t._v("勾选 Support HTTP/2")])])]),t._v(" "),a("li",[t._v("确定手机端代理地址，与Charles安装机器的IP匹配")]),t._v(" "),a("li",[t._v("点击Charles 的菜单help–>SSL Proxying–> Install Charles Root Ceriticate On a Mobile Device or Remote Browser，弹窗点击允许")]),t._v(" "),a("li",[t._v("在App端，通过浏览器访问网页：chls.pro/ssl，并下载安装证书，有些Android手机下载失败，需要关闭手机自带的迅雷加速")]),t._v(" "),a("li",[t._v("另外，有些设备特别是 Android 设备无法直接安装下载的证书，需要进入到设置->安全->凭据存储 ->从存储设备安装证书")])]),t._v(" "),a("h2",{attrs:{id:"接口过滤、拦截和修改-过滤接口请求与动态修改请求数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口过滤、拦截和修改-过滤接口请求与动态修改请求数据"}},[t._v("#")]),t._v(" 接口过滤、拦截和修改（过滤接口请求与动态修改请求数据）")]),t._v(" "),a("h3",{attrs:{id:"过滤接口请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过滤接口请求"}},[t._v("#")]),t._v(" 过滤接口请求")]),t._v(" "),a("p",[t._v("因为所有的网络请求都会被抓取，那么信息太多也会造成干扰，所以可以过滤接口的请求，过滤接口的请求方式有 2 种")]),t._v(" "),a("ol",[a("li",[t._v("直接过滤\n"),a("ul",[a("li",[t._v("直接过滤很简单，直接在 Charles 的 Filter 这栏中填写你要过滤的关键字即可")])])]),t._v(" "),a("li",[t._v("通过菜单 Recording Settings 设置\n"),a("ul",[a("li",[t._v("首先，通过 Charles 菜单选择 Proxy--\x3eRecording Settings")]),t._v(" "),a("li",[t._v("接着在弹出的对话框中，选择 Include， 然后点击 Add 按钮，并按照你的需求设置 Filter。注意：如果你什么都不填写，就表示全部符合条件")])])])]),t._v(" "),a("h3",{attrs:{id:"动态修改请求数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态修改请求数据"}},[t._v("#")]),t._v(" 动态修改请求数据")]),t._v(" "),a("ol",[a("li",[t._v("当发送给服务端的数据需要进行修改时，最简单的方式就是找到这个请求，然后鼠标右键，并选择 Breakpoints")]),t._v(" "),a("li",[t._v("当这请求再次被触发时，它就会被拦截")]),t._v(" "),a("li",[t._v("此时，再点击 EditRequest，将会看到请求的所有参数，直接更改后点击 Execute 执行")]),t._v(" "),a("li",[t._v("你还可以对服务端返回的数据进行修改")]),t._v(" "),a("li",[t._v("点击 Edit Response，选择 JSON Text 标签，即可对请求的各项返回进行更改")]),t._v(" "),a("li",[t._v("一个接口一个接口地打断点毕竟太浪费时间，除此之外，还可以自定义 BreakPoint Settings， 方法如下：\n"),a("ul",[a("li",[t._v("菜单栏选择 Proxy--\x3eBreakPoint Settings")]),t._v(" "),a("li",[t._v("然后在 Breaking Setting 中，勾选“Enable BreakPoints”，点击 Add 按钮")]),t._v(" "),a("li",[t._v("可以根据需求，自定义要抓取的请求地址")]),t._v(" "),a("li",[t._v("并且可以通过勾选 Request、Reponse 的方式来决定是只更改发往服务端的请求数据，还是更改服务端返回的响应数据")])])])]),t._v(" "),a("h2",{attrs:{id:"远程映射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#远程映射"}},[t._v("#")]),t._v(" 远程映射")]),t._v(" "),a("ol",[a("li",[t._v("通过 Breakpoint 的方式进行修改请求数据虽然有效，但是修改请求这个操作需要人工干预，需要花费时间。再者，在测试时有可能接口返回，你已经提前知道了，那么就不需要先请求再更改数据，可以准备好返回数据直接进行模拟")]),t._v(" "),a("li",[t._v("方式为点击 Tools --\x3e Map Local，然后在弹出的对话框中，勾选“Enable Map Local”，接着设置你要覆盖的请求")]),t._v(" "),a("li",[t._v("注意：Map From 是你的原始请求。Map To 是你期望的结果，这个结果你可以放在本地文件中，以 Text 或者 Json 的格式保持都可以。当你使用 Map Local 后，当有目标请求发生时，Charles 直接将你提供的文件内容当做返回值返回")]),t._v(" "),a("li",[t._v("远程映射常常用于客户端或者服务端，对返回的时间有超时判断，或者需要更改太多服务端返回值时使用。 毕竟一个个更改接口返回值需要花费时间，而由于超时时间非常短，等你改完再去执行，接口就直接超时了，这个时候就需要用到远程映射来直接更改")])]),t._v(" "),a("h2",{attrs:{id:"慢网络模拟"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#慢网络模拟"}},[t._v("#")]),t._v(" 慢网络模拟")]),t._v(" "),a("p",[t._v("从菜单 Porxy--》Throttle Settings 进入，先通过 Add 添加你要进行网络速度限制的站点，然后勾选“Enable Throttling”，选择“Throttle preset”，这个时候你会看到不同的网络速度情况，可以根据需要选择，即可完成网络速度限制")]),t._v(" "),a("h2",{attrs:{id:"微服务分支测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务分支测试"}},[t._v("#")]),t._v(" 微服务分支测试")]),t._v(" "),a("ol",[a("li",[t._v("在采用微服务架构后，我们就需要对不同版本的微服务分支进行测试，那么这就有必要进行分支测试。在当下，分支测试通常都是根据 Header 进行区分。既然如此，我们就可以给指定的请求添加 Header，以 Charles 也可以进行微服务分支测试，方式如下：")]),t._v(" "),a("li",[t._v("菜单 Tools -> Rewrite，然后勾选“Enable Rewrite”“Debug in Error Log”，点击 Add，并在右上的 Location 这个栏目下，点击 Add。")]),t._v(" "),a("li",[t._v("在弹出的对话框中， Host 输入*，点击 OK")]),t._v(" "),a("li",[t._v("输入* 代表任何地址都将被 Rewrite")]),t._v(" "),a("li",[t._v("然后继续点击 Add 按钮")]),t._v(" "),a("li",[t._v("配置 Rewrite 的规则")]),t._v(" "),a("li",[t._v("其中，Type 的值是个下拉列表， 选择 add Header，where 勾选 Request")]),t._v(" "),a("li",[t._v("然后在下方 Replace 栏目，输入你想增加的 header 的 key 和 value，保存即可")])]),t._v(" "),a("h2",{attrs:{id:"简单接口并发测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单接口并发测试"}},[t._v("#")]),t._v(" 简单接口并发测试")]),t._v(" "),a("ol",[a("li",[t._v("针对某个接口，假设我们想测试其基本的并发性能，直接选择这个接口，右键选择 Repeat Advanced")]),t._v(" "),a("li",[t._v("此时，会弹出设置的框让你选择，其中：\n"),a("ul",[a("li",[t._v("Iterations：是并发轮次数，进行多少轮次的测试")]),t._v(" "),a("li",[t._v("Concurrency：是并发线程数，每轮测试几个请求同时发")]),t._v(" "),a("li",[t._v("Repeat delay：可设置轮次之间的间隔，以毫秒计算")])])]),t._v(" "),a("li",[t._v("点击确定，会看到所有的请求都发出来了。通过这种方式，压力就产生了，我们可以观察服务端的响应时间来判断起基本的性能是否达标")])]),t._v(" "),a("h2",{attrs:{id:"charles-应用常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#charles-应用常见问题"}},[t._v("#")]),t._v(" Charles 应用常见问题")]),t._v(" "),a("h3",{attrs:{id:"【question-1-】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【question-1-】"}},[t._v("#")]),t._v(" 【Question 1 】")]),t._v(" "),a("ul",[a("li",[t._v("问：配置好 Charles 后，浏览网页提示“您的连接不是私密连接”")]),t._v(" "),a("li",[t._v("答：打开 SSL Proxying Setting，在弹出的对话框中，做如下操作。\n"),a("ul",[a("li",[t._v("勾选 Enable SSL Proxying；")]),t._v(" "),a("li",[t._v("点击 ADD 按钮，编辑如下。")]),t._v(" "),a("li",[t._v("Host 填*，Port 填写 443，这样就可以抓取 https 的请求了。")])])])]),t._v(" "),a("h3",{attrs:{id:"【question-2-】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【question-2-】"}},[t._v("#")]),t._v(" 【Question 2 】")]),t._v(" "),a("ul",[a("li",[t._v("问：Charles 关闭，电脑端就无法上网了，为什么？")]),t._v(" "),a("li",[t._v("答：查看电脑的网络设置->高级设置->代理，检查并取消选中 HTTP 和 HTTPS 代理选项。")])]),t._v(" "),a("h3",{attrs:{id:"【question-3-】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【question-3-】"}},[t._v("#")]),t._v(" 【Question 3 】")]),t._v(" "),a("ul",[a("li",[t._v("问： iOS 上证书安装了，但是无法抓包，为什么？")]),t._v(" "),a("li",[t._v("答： 两个检查。\n"),a("ul",[a("li",[t._v("检查是否信任该证书。 在手机设置->通用->关于本机->证书信任设置中信任。")]),t._v(" "),a("li",[t._v("通用->描述文件与设备管理，选中安装的配置文件，并验证。")])])])]),t._v(" "),a("h3",{attrs:{id:"【question-4-】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【question-4-】"}},[t._v("#")]),t._v(" 【Question 4 】")]),t._v(" "),a("ul",[a("li",[t._v("问：App 端开启代理，为什么 Charles 没有出现“允许”提示？")]),t._v(" "),a("li",[t._v("答： App 端和电脑端必须连接同一个网络。")])]),t._v(" "),a("h3",{attrs:{id:"【question-5-】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【question-5-】"}},[t._v("#")]),t._v(" 【Question 5 】")]),t._v(" "),a("ul",[a("li",[t._v("问：某些安卓机型证书下载后无法直接安装。")]),t._v(" "),a("li",[t._v("答：通常见于安卓机，例如小米手机。证书下载后，从“更多设置->系统安全->从存储设备安装”这个路径进行安装。")])]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=1073#/detail/pc?id=8324",target:"_blank",rel:"noopener noreferrer"}},[t._v("拉钩教育"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.zzzmode.com/mytools/charles/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Charles破解地址"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);